＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
カスタムコントロールの実装ガイド
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

・司エンジンでは標準で提供されているコントロールの他、ユーザーがカスタムコントロールを作成することが可能です。
・作成したカスタムコントロールはtsukasa/pluguin_controlフォルダに配置すると自動的に読み込まれます。
・ここではカスタムコントロールの実装方法について簡単に説明します。実際のソースコードも参照してください。

・カスタムコントロールはTsukasa::Controlクラス（あるいはその派生クラス）を継承します。クラス名を_CREATE_で指定出来るようになります。
・コマンドは以下のインターフェイスを満たすメソッドを実装すると、司スクリプト上から呼びだせるようになります。

  def _CHECK_BLOCK_(**options){
  
  }

・コマンド名は自由に設定して構いません。司エンジンの標準コントロールのコマンド名は「前後にアンダーバーを付けた大文字」という形式で統一されていますが、これはrubyの予約語と衝突しないようにした為です。

・Controlクラスに実装されている以下のメソッドを使用できます。

■クラスの初期化（オーバーライド可能）

initialize(system, **options)

・クラスの初期化メソッドです。
・system：司エンジン内部で使用する値が配列で格納されています。systemの内部の値は変更しないでください。変更した場合の動作は未検証になります。
・options：_CREATE_に渡されたオプションがハッシュで格納されます。

■メインループ関連（オーバーライド可能）

update(mouse_pos_x, mouse_pos_y)
・毎フレーム毎に呼びだされます。更新処理を行います。
・全てのコントロールについてupdateが実行された後、renderが実行されます。
・mouse_pos_x/mouse_pos_y：コントロールの左上を原点としたマウスカーソルの相対座標が格納されます。

render(target)
・毎フレーム毎に呼びだされます。描画処理を行います。
・target：自身を描画する対象の描画ターゲットが格納されます。

■コマンド処理（オーバーライド不可）

unshift_command(command, **options, &block)
・コマンドをスタックの先頭に挿入します。

push_command( command, **options, &block)
・コマンドをスタックの末端に挿入します。

unshift_command_array(command_array)
・コマンド配列をスタックの先頭に挿入します

push_command_array(command_array)
・コマンド配列をスタックの末尾に挿入します

unshift_command_block(**options)
・司スクリプト上でコマンドに付与されたブロックをパースしてコマンド配列化し、コマンドリストの先頭に挿入します

push_command_block(**options)
・司スクリプト上でコマンドに付与されたブロックをパースしてコマンド配列化し、コマンドリストの先頭に挿入します

command_block?()
・司スクリプト上でコマンドが付与されている場合にtrueを返します。

■コントロール検索（オーバーライド不可）

child_control(id)
・そのコントロールが保持している子コントロールリストを検索し、該当するコントロールを返します。
・id：[シンボル]検索対象のコントロールのid名

find_control(control_path)
・コントロールへの相対パスを指定して、任意のコントロールを取得します。
・control_path：[配列][シンボル]コントロールへの相対パス。

■条件判定（オーバーライド可能）

check_imple(condition, value)
・そのコントロールで_CHECK_が実行された際に呼びだされます。このメソッドをオーバーライドすることで、_CHECK_の条件を独自に拡張できます。
・condition：[シンボル]判定条件が格納されます。
・value：[ハッシュ]conditionに設定されたハッシュが格納されます。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
レンダリング済みフォント作成方法
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
・司エンジンではWindowsにインストールされているTrueTypeフォントの他、専用のツールで事前に変換したレンダリング済みフォントデータを使用できます。ツールはtsukasa/toolsに収録されているFontDataMaker.rbで、コマンドライン上から使用します。書式は以下の通りです。

>ruby FontDataMaker.rb size font_name file_name

size：司エンジンで使用する際のフォントサイズ（省略時：３２）
font_name：変換するフォントの名称（省略時："ＭＳ Ｐゴシック"）
file_name：出力ファイル名（省略時："FontData01.dat"）

・変換したファイルは_INSTALL_PRERENDER_FONT_コマンドでインストールできます。
・コンバート後のデータの再配布については、コンバート元のフォントのライセンスに従ってください。

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
ユニットテスト(RSpec)
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝

・tsukasa/specフォルダには司エンジンの動作を検証するユニットテスト用ソースコードが格納されています。
・下記のようにrakeを実行することで、specフォルダ直下の全てのユニットテストコードを実行します。

>rake spec

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
ユニットテスト(Minitest)
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
※Minitest版は将来的に削除予定です。RSpec版を使用してください。

・tsukasa/testフォルダには司エンジンの動作を検証するユニットテスト用ソースコードが格納されています。
・下記のようにrakeを実行することで、testフォルダ直下の全てのユニットテストコードを実行します。

>rake test
